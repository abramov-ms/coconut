# Кордампы

Попробуем получить очевидный сегфолт и потом "расследовать" его.

```c
// main.c

void bar() {
}

void foo(int arg) {
  *((int*)&bar) = arg;
}

int main() {
  int local = 100500;
  foo(42);
}
```

Нам потребуются дебаг-символы, поэтому надо компилировать с флагом `-g`.

```bash
gcc main.c -g -o main
```

Если эту программу запустить, получим сообщение в стиле

```
[1]    243872 segmentation fault (core dumped)  ./main
```

Сообщение говорит, что был сделан кордамп --- снимок памяти процесса в момент
сегфолта (принято говорить, что процесс "упал в корку"). Его можно
использовать, чтобы расследовать, почему программа упала. Кордампы хороши тем,
что они могут храниться долго. Даже если процесс крашнулся неделю назад, по
_core-файлу (корке)_ все еще можно узнать, из-за чего это произошло.

Общего рецепта как найти core-файлы, к сожалению, нет. Все зависит от
дистрибутива линукса, иногда их нужно отдельно включать или поднимать лимиты на
суммарный размер хранимых корок. У счастливых обладателей арча сработает
[`coredumpctl`](https://man7.org/linux/man-pages/man1/coredumpctl.1.html). Если
выполнить `coredumpctl list`, получим список всех кордампов за последнее время.
У меня недавно крашился хромиум и вот эта программа.

```
Sun 2023-08-20 01:45:01 MSK   3485 1000 1000 SIGSYS  missing  /usr/lib/chromium/chromium
Sun 2023-08-20 01:45:01 MSK   3484 1000 1000 SIGTRAP missing  /usr/lib/chromium/chromium
Sun 2023-08-20 01:45:06 MSK   3475 1000 1000 SIGTRAP missing  /usr/lib/chromium/chromium
Tue 2023-09-05 18:44:31 MSK 243872 1000 1000 SIGSEGV present  /home/dgdh/Documents/coconut/main
```

`coredumpctl info` выдает подробный статус по последнему кордампу.
```
           PID: 243872 (segfault)
           UID: 1000 (dgdh)
           GID: 1000 (dgdh)
        Signal: 11 (SEGV)
     Timestamp: Tue 2023-09-05 18:44:31 MSK (17min ago)
  Command Line: ./main
    Executable: /home/dgdh/Documents/coconut/main
 Control Group: /user.slice/user-1000.slice/session-1.scope
          Unit: session-1.scope
         Slice: user-1000.slice
       Session: 1
     Owner UID: 1000 (dgdh)
       Boot ID: a9507c82398b4d4cae9609c2bdedc20d
    Machine ID: d7a99c1702e643a3a8acdecda4785c85
      Hostname: arch
       Storage: /var/lib/systemd/coredump/core.main.1000.a9507c82398b4d4cae9609c2bdedc20d.243872.1693928671000000.zst (present)
  Size on Disk: 17.0K
       Message: Process 243872 (main) of user 1000 dumped core.

                Stack trace of thread 243872:
                #0  0x000056257641913b n/a (/home/dgdh/Documents/coconut/main + 0x113b)
                #1  0x00007febfae27cd0 n/a (libc.so.6 + 0x27cd0)
                #2  0x00007febfae27d8a __libc_start_main (libc.so.6 + 0x27d8a)
                #3  0x0000562576419045 n/a (/home/dgdh/Documents/coconut/main + 0x1045)
                ELF object binary architecture: AMD x86-64
```

В ключе `Storage` написано, где лежит кордамп. Расширение `.zst`, потому что он
был запакован в архив. Чтобы распаковать последний кордамп, нужно выполнить
`coredumpctl dump > main.core` (по умолчанию дамп печатается на `stdout` и его
надо перенаправить в файлик).

Теперь можно открыть кордамп в дебаггере и посмотреть, что привело к сегфолту.
Я буду использовать для этого [`gdb`](https://www.sourceware.org/gdb/), как
вариант то же самое можно сделать через [`lldb`](https://lldb.llvm.org/).
```bash
gdb ./main ./main.core
```
Получаем такой вывод.
```
Core was generated by `./main'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x000055a668c1e13a in foo (arg=42) at main.c:5
5         *((int*)&bar) = arg;
```

Теперь попробуем осмотреться вокруг. Вот хорошая
[шпаргалка](https://users.ece.utexas.edu/~adnan/gdb-refcard.pdf) по командам
gdb. `bt` (означает "backtrace") показывает стек вызовов функций, начиная с
мейна. В момент сегфолта мы находились внутри `foo()`, который был вызван
`main()`-ом.

```
(gdb) bt
#0  0x000055a668c1e13a in foo (arg=42) at main.c:5
#1  0x000055a668c1e170 in main () at main.c:10
```

Теперь посмотрим локальные переменные. Команда `fr` позволяет сфокусироваться
на стековом фрейме --- области памяти, в которой хранятся аргументы и локальные
переменные при вызове функции. У нас есть два фрейма: вызов `main()` и вызов
`main() -> foo()` --- как раз их показал `bt`. Смотреть локальные переменные и
аргументы можно через команду `info`.

```
(gdb) fr 0
(gdb) info args
arg = 42
(gdb) fr 1
(gdb) info locals
local = 100500
```

Таким способом можно понять, почему упала программа. Единственный минус ---
чтобы кордампы были информативными, надо включать в бинарник дебаг-символы и
желательно еще компилировать без оптимизаций. Поэтому в продакшене будет не
настолько удобно, как в нашем примере.

> Более простой способ отдебажить корку --- `coredumpctl gdb`. Эта команда
> просто откроет последний кордамп в дебаггере.

> Еще можно просто запустить `./main` под gdb. Тогда в момент сегфолта
> поставится брейкпоинт и можно будет точно так же осматриваться вокруг.
