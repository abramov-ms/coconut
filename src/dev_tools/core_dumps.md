# Кордампы

Давайте попробуем получить очевидный сегфолт и потом "расследовать" его.
```c
// main.c

void bar() {
}

void foo(int arg) {
  *((int*)&bar) = arg;
}

int main() {
  int local = 100500;
  foo(42);
}
```

Нам потребуются дебаг-символы, поэтому надо компилировать с флагом `-g`.
```bash
clang main.c -g -o main
```

Если эту программу запустить, получим сообщение в стиле
```
[1]    243872 segmentation fault (core dumped)  ./main
```

Сообщение говорит, что был сделан кордамп &mdash; снимок памяти процесса в
момент сегфолта. Его можно использовать, чтобы расследовать, почему программа
упала. Кордампы хороши тем, что они могут храниться долго. Даже если процесс
крашнулся неделю назад, по кордампу все еще можно узнать, из-за чего это
произошло.

Кордампы могут лежать в разных папках в зависимости от твоего дистрибутива
линукса. Самый простой способ их найти &mdash; утилита
[`coredumpctl`](https://man7.org/linux/man-pages/man1/coredumpctl.1.html). Если
выполнить `coredumpctl list`, получим список всех кордампов за последнее время.
У меня недавно крашился хромиум и вот эта программа.
```
Sun 2023-08-20 01:45:01 MSK   3485 1000 1000 SIGSYS  missing  /usr/lib/chromium/chromium
Sun 2023-08-20 01:45:01 MSK   3484 1000 1000 SIGTRAP missing  /usr/lib/chromium/chromium
Sun 2023-08-20 01:45:06 MSK   3475 1000 1000 SIGTRAP missing  /usr/lib/chromium/chromium
Tue 2023-09-05 18:44:31 MSK 243872 1000 1000 SIGSEGV present  /home/dgdh/Documents/coconut/main
```

`coredumpctl info` выдает подробный статус по последнему кордампу.
```
           PID: 243872 (segfault)
           UID: 1000 (dgdh)
           GID: 1000 (dgdh)
        Signal: 11 (SEGV)
     Timestamp: Tue 2023-09-05 18:44:31 MSK (17min ago)
  Command Line: ./main
    Executable: /home/dgdh/Documents/coconut/main
 Control Group: /user.slice/user-1000.slice/session-1.scope
          Unit: session-1.scope
         Slice: user-1000.slice
       Session: 1
     Owner UID: 1000 (dgdh)
       Boot ID: a9507c82398b4d4cae9609c2bdedc20d
    Machine ID: d7a99c1702e643a3a8acdecda4785c85
      Hostname: arch
       Storage: /var/lib/systemd/coredump/core.main.1000.a9507c82398b4d4cae9609c2bdedc20d.243872.1693928671000000.zst (present)
  Size on Disk: 17.0K
       Message: Process 243872 (main) of user 1000 dumped core.

                Stack trace of thread 243872:
                #0  0x000056257641913b n/a (/home/dgdh/Documents/coconut/main + 0x113b)
                #1  0x00007febfae27cd0 n/a (libc.so.6 + 0x27cd0)
                #2  0x00007febfae27d8a __libc_start_main (libc.so.6 + 0x27d8a)
                #3  0x0000562576419045 n/a (/home/dgdh/Documents/coconut/main + 0x1045)
                ELF object binary architecture: AMD x86-64
```

В ключе `Storage` написано, где лежит кордамп. Расширение `.zst`, потому что он
был запакован в архив. Чтобы распаковать последний кордамп, нужно выполнить
`coredumpctl dump > main.core` (по умолчанию дамп печатается на `stdout` и его
надо перенаправить в файлик).

Теперь можно открыть кордамп в дебаггере и посмотреть, что привело к сегфолту.
Я буду использовать для этого [`gdb`](https://www.sourceware.org/gdb/), как
вариант то же самое можно сделать через [`lldb`](https://lldb.llvm.org/).
```bash
gdb ./main ./main.core
```
Получаем такой вывод.
```
Core was generated by `./main'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x000055a668c1e13a in foo (arg=42) at main.c:5
5         *((int*)&bar) = arg;
```

Теперь попробуем осмотреться вокруг. Вот хорошая
[шпаргалка](https://users.ece.utexas.edu/~adnan/gdb-refcard.pdf) по командам
gdb. `bt` (означает "backtrace") показывает стек вызовов функций, начиная с
мейна. В момент сегфолта мы находились внутри `foo()`, который был вызван
`main()`-ом.
```
(gdb) bt
#0  0x000055a668c1e13a in foo (arg=42) at main.c:5
#1  0x000055a668c1e170 in main () at main.c:10
```
Теперь посмотрим локальные переменные. Команда `select-frame` позволяет
сфокусироваться на стековом фрейме &mdash; области памяти, в которой хранятся
аргументы и локальные переменные при вызове функции. У нас есть два фрейма:
вызов `main()` и вызов `main() -> foo()` &mdash; как раз их
показал `bt`. Смотреть локальные переменные и аргументы можно через команду
`info`.
```
(gdb) select-frame 0
(gdb) info args
arg = 42
(gdb) select-frame 1
(gdb) info locals
local = 100500
```

Таким способом можно понять, почему упала программа. Единственный минус &mdash;
чтобы кордампы были информативными, надо включать в бинарник дебаг-символы и
желательно еще компилировать без оптимизаций. Поэтому в продакшене будет не
настолько удобно, как в нашем примере.

> Еще можно просто запустить `./main` под gdb. Тогда в момент сегфолта
> поставится брейкпоинт и можно будет точно так же осматриваться вокруг.
