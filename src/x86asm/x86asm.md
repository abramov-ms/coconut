# Ассемблер x86

В этом разделе поговорим про ассемблер семейства архитектур x86.

_Ассемблером (assembly language)_ называют специальный низкоуровневый язык
программирования. Он оперирует на уровне инструкций процессора и его регистров
--- ограниченного набора физических ячеек памяти, над которыми производятся
вычисления.

По неудачному стечению обстоятельств, точно также _ассемблером (assembler)_ еще
называется компилятор языка ассемблера в объектные файлы. В gcc встроен
ассемблер [`as`](https://linux.die.net/man/1/as), еще бывают standalone
ассемблеры, например, [nasm](https://www.nasm.us/).

Для компилируемых языков программирования ассемблер --- одно из промежуточных
представлений кода при сборке исполняемого бинарника. В случае C/C++ можно
увидеть, в какой ассемблер транслируется программа, передав компилятору флаг
`-S`.

Скомпилируем этот код в ассемблер.

```c
// aplusb.c

void aplusb(int a, int b) {
  return a + b;
}
```

Традиционно ассемблерные файлы имеют расширение `.S`. Иногда еще бывает
маленькая `.s`. Отличается только тем, что в `.S`-файлах можно использовать
макросы препроцессора (`#include`, `#define` и другие), а в `.s` --- нельзя.

```bash
gcc aplusb.c -S -O2 -o aplusb.S
```

Полученный ассемблер выглядит так.

```x86asm
// aplusb.S

	.file	"aplusb.c"
	.text
	.p2align 4
	.globl	aplusb
	.type	aplusb, @function
aplusb:
.LFB0:
	.cfi_startproc
	leal	(%rdi,%rsi), %eax
	ret
	.cfi_endproc
.LFE0:
	.size	aplusb, .-aplusb
	.ident	"GCC: (GNU) 14.2.1 20240910"
	.section	.note.GNU-stack,"",@progbits
```

В нем можно выделить три основных компонента.

1. Метки (`aplusb`, `.LFB0`, `.LFE1`). Они ставятся перед функциями,
   вспомогательными кусочками кода, объявлениями констант и глобальных
   переменных. На метки можно ссылаться в ассемблерном коде, например, прыгнуть
   на метку с помощью инструкции `jmp` --- ассемблерного аналога `goto` из Си.
1. Инструкции (`leal`, `ret`). Это "атомарные" действия, которые исполняет
   процессор. Они могут оперировать над регистрами (`%rdi`, `%rsi`, `%eax`),
   константами, или обращаться в память.
1. Служебные директивы (`.text`, `.globl`, `.section`). В основном
   они влияют на настройки синтаксиса ассемблера и структуру итогового
   бинарника. Например, `.ident	"GCC: (GNU) 14.2.1 20240910"` говорит, что в
   бинарник нужно вкомпилировать такой "комментарий" с указанием версии gcc. А
   `.globl aplusb` _экспортирует_ функцию --- без этой директивы она
   была бы не видна при линковке.

Инструкции, написанные на ассемблере, практически один в один соответствуют
машинным кодам, поэтому бинарные файлы можно _дизассемблировать_. Мы будем это
делать с помощью утилиты [`objdump`](https://linux.die.net/man/1/objdump).

```bash
gcc aplusb.c -c -o aplusb.o
objdump -d aplusb
```

Вывод похож на то, что уже видели выше.

```x86asm
aplusb.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <aplusb>:
   0:   8d 04 37                lea    (%rdi,%rsi,1),%eax
   3:   c3                      ret
```

Слева записаны _опкоды_ --- байты, которыми кодируются инструкции, а справа их
_мнемоники_ --- человекочитаемые (если честно, не очень) названия. Одни и те же
инструкции могут кодироваться разными мнемониками. В нашем дизассемблере
по-другому стал выглядеть вызов [`lea`](https://www.felixcloutier.com/x86/lea).

При компиляции вырезаются метки, которые начинались с `.L`. Считается, что они
служебные --- обычно под ними записываются разные ветки `if` или тело цикла. В
итоговом бинарнике у них нет названий, есть только числовые адреса. 

Исторически у ассемблера x86 появилось два диалекта --- AT&T и Intel.
Считается, что синтаксис Intel удобнее, зачастую в примерах и документации
используется он. Тем не менее в дикой природе чаще встречается AT&T, поэтому
полезно знать оба варианта. Показанное в примерах выше --- AT&T, а Intel можно
получить так.

```bash
gcc aplusb.c -masm=intel -S -o aplusb.S
```

В начале файлика будет написано `.intel_syntax noprefix`, и синтакис инструкций
изменится.

```x86asm
// aplusb.S

	.file	"aplusb.c"
	.intel_syntax noprefix
	.text
	.p2align 4
	.globl	aplusb
	.type	aplusb, @function
aplusb:
.LFB0:
	.cfi_startproc
	lea	eax, [rdi+rsi]
	ret
	.cfi_endproc
.LFE0:
	.size	aplusb, .-aplusb
	.ident	"GCC: (GNU) 14.2.1 20240910"
	.section	.note.GNU-stack,"",@progbits
```

Пока что не вдаваясь в детали, на примере `lea (%rdi,%rsi), %eax` (AT&T) vs.
`lea eax, [rdi+rsi]` (Intel) основные отличия такие.
1. Перед названиями регистров не нужно писать `%`, а перед константами `$` (это
   и означает `noprefix`).
1. Чтобы задать адрес в памяти используется конструкция вида `[base + index *
   scale + offset]` вместо `(base, index, scale, offset)`.
1. Результат операции записывается в первый операнд, а не в последний (т.е.
   присваивание как бы происходит справа налево). В нашем примере `lea` пишет в
   регистр `eax` адрес, равный `rdi + rsi`.

Регистры --- это ячейки памяти, в которых процессор производит вычисления. Они
бывают разными.
[Картинку](https://en.wikipedia.org/wiki/X86#/media/File:Table_of_x86_Registers_svg.svg)
проще рассмотреть в отдельной вкладке.

![Регистры x86](x86_regs.svg)

Основные виды регистров.
1. General purpose регистры `rax`, `rbx`, `rcx`, `rdx`, `rdi`, `rsi` и
   `r8`--`r15`. Они используются как слоты для числовых переменных и
   указателей. Такие регистры 64-битные. На более старых процессорах были
   только 32-, 16- и 8-битные регистры. Например, `eax` --- младшие 32 бита
   `rax`, `ax` --- младшие 16 бит `eax`, а `al` (lower) и `ah` (higher) ---
   8-битные половинки `ax`.
1. Системные регистры: `rflags` --- флаги, которые проставляются при сравнениях
   чисел и в результате арифметических операций, `rip` --- указатель на текущую
   инструкцию, `rsp` --- указатель на верхушку стека, `rbp` --- указатель на
   границу стекового фрейма. Их подробнее обсудим позже.
1. Широкие регистры `xmm0`--`xmm15`, `ymm0`--`ymm15` и `zmm0`--`zmm15`. Они
   тоже росли постепенно, поэтому вложены друг в друга. Такие регистры
   используются для "векторных" операций: например, в них можно
   записать несколько `int32_t` и потом попарно сложить как короткие векторы.
   Еще эти регистры по совместительству используются для вещественной
   арифметики, в них можно хранить `float` и `double`.
1. Стековые регистры сопроцессора [x87](https://en.wikipedia.org/wiki/X87)
   `st(0)`--`st(7)`. В более старых процессорах вещественная арифметика была
   реализована в отдельном
   [FPU](https://en.wikipedia.org/wiki/Floating-point_unit) --- сопроцессоре
   x87. Чтобы передать в него данные и получить обратно, использовались эти
   регистры.
1. Регистры с настройками --- `cr0`--`cr15`, `cs`, `ss`, `ds`, `es`, `fs` и
   многие другие. Например, `cr0` и `cr3`
   [влияют](https://wiki.osdev.org/Paging) на то, как процессор будет ходить в
   память, отображая виртуальные адреса (собственное адресное пространство для
   каждого процесса) в физические (общее адресное пространство внутрий всей
   оперативной памяти).
