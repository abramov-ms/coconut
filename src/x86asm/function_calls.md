# Вызовы функций

На x86 вызовы функций реализуются инструкциями
[`call`](https://www.felixcloutier.com/x86/call) (вызов функции) и
[`ret`](https://www.felixcloutier.com/x86/ret) (возврат из функции).

```x86asm
aplusb:
    lea rax, [rdi + rsi]
    ret

main:
    mov rdi, 21
    mov rsi, 21
    call aplusb
    ret
```

Существуют различные соглашения ([calling
conventions](https://en.wikipedia.org/wiki/X86_calling_conventions)) о том, как
передавать в функции аргументы и получать возвращаемые значения.

Calling conventions --- часть более широкого понятия
[ABI](https://en.wikipedia.org/wiki/Application_binary_interface) (application
binary interface). ABI описывает, как должны быть устроены исполняемые
бинарники (и, следовательно, каким должен быть ассемблерный код), чтобы они
могли взаимодействовать друг с другом.

В Linux используется System V ABI, унаследованный от более старой комерческой
операционки [System V](https://en.wikipedia.org/wiki/UNIX_System_V). С
развитием архитектур процессоров в System V ABI вносились дополнения
(supplements). Нам потребуется supplement для x86-64, его можно скачать
[здесь](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf).

## `3.2.3 Parameter passing`

System V ABI задает соответствие между функциями на языке Си и их
представлением в ассемблерном коде. Правила вызова функций такие.

1. Адрес верхушки стека `rsp` должен быть кратен 16. Такое требование, чтобы в
   некоторых случаях было удобнее выравнивать локальные переменные на стеке.
1. Целочисленные аргументы и указатели передаются в регистрах `rdi`, `rsi`,
   `rdx`, `rcx`, `r8`, `r9`. Если их больше шести, оставшиеся записываются на
   стек. Указатели и целые числа возвращаются в регистре `rax`.
1. Вещественные аргументы (`float`, `double`) передаются в регистрах
   `xmm0`--`xmm7`. Вещественное возвращаемое значение записывается также в
   `xmm0`. Если аргументов больше восьми, оставшиеся записываются на стек.
1. Существуют _callee-saved_ регистры --- `rbx`, `rsp`, `rbp`, `r12`--`r15`. Их
   нельзя "портить", т.е. после вызова функции значения таких регистров не
   должны измениться. Поскольку callee-saved --- только некоторые регистры,
   компиляторы могут генерировать более эффективный код.
   * Если бы все регистры можно было портить, то перед вызовом любой функции
     все текущие регистры нужно было бы куда-то сохранять.
   * А если бы никакие регистры нельзя было портить, то в теле каждой функции
     сначала надо было бы сохранять все регистры, а в конце восстанавливать.
1. Более сложные типы могут передаваться через стек или несколько регистров.
   Например, `struct Point { int x; int y; }` будет передаваться через два
   регистра.

# Стековые фреймы

Стековым фреймом называется область памяти, в которой хранятся локальные
переменные функции и _адрес возврата_. При вызовах цепочек функций фреймы
вкладываются друг в друга.

В примере ниже переменные на самом деле будут передаваться в регистрах. Но если
бы их было больше --- некоторые отправились бы на стек.

<img data-src="stack_frames.svg">

Инструкция `call LABEL` записывает на стек адрес возврата --- адрес следующей
после `call` инструкции --- и выполняет `jmp LABEL`. В свою очередь `ret`
читает с верхушки стека адрес возврата и делает `jmp` на него. Поэтому при
заходе в функцию и перед выполнением `ret` значение `rsp` должно быть
одинаковым --- чтобы прочитался сохраненный адрес.

При входе в функцию значение `rsp` всегда будет иметь остаток 8 по модулю 16.
По calling conventions в момент вызова `call` значение `rsp` кратно 16, а сам
`call` кладет на стек еще 8-байтовый адрес возврата.

## Выделение переменных на стеке

На Linux память процесов всегда устроена примерно одинаково. В ней есть стек,
куча и некоторые секции, которые отображаются в память из исполняемого
бинарника.

Секции мы подробнее обсудим позже. Пока что на картике
1. `text` --- машинные инструкции программы, соответствуют секции `.text` в
   бинарнике.
1. `data`, `rodata` --- глобальные переменные и константы, в бинарнике для них
   есть секции `.data` и `.rodata`.
1. `bss` --- участок памяти, забитый нулями. Он соответствует глобальным
   переменным, которые по умолчанию инициализируются нулем. Нули нет смысла
   хранить в бинарнике, поэтому есть секция `.bss`, в которой записано только
   их суммарное количество. При старте процесса эти нули "материализуются" в
   памяти.

<img data-src="memory_layout.svg">

Стек растет от больших адресов к меньшим. Поэтому в ассемблере выделение памяти
на стеке --- просто `sub rsp, SIZE`, а деаллокация --- `add rsp, SIZE`.

### Как вызвать `scanf`

Посмотрим на небольшой пример полноценной функции на ассемблере. Так можно
сделать `scanf("%d", &x)`, выделив под `x` место на стеке.

```x86asm
// scan_int.S

  // Включаем синтаксис Intel.
  .intel_syntax noprefix

  // Нужно, чтобы scan_int был виден при линковке.
  .global scan_int

  // Начинаем секцию с инструкциями.
  .text

scan_int:
   // Выделяем слот под x плюс выравниваем стек. Теперь значение rsp кратно 16.
   sub rsp, 8

   // Подгружаем адрес формат-строки в rdi.
   mov rdi, offset scanf_str

   // В rsi будет поинтер на новое место на стеке.
   mov rsi, rsp

   call scanf

   // Прочитанный int возвращается из функции через rax.
   mov rax, [rsp]

   // Возвращаем стек к исходному состоянию.
   add rsp, 8

   ret

  // Объявление секции с данными.
  .section .rodata

scanf_str:
  // Константная строка в секции read-only данных.
  .string "%d"   
```

## Стектрейсы

Если передать компилятору флаг `-fno-omit-frame-pointer`, он будет аннотировать
вход и выход из функций специальным _прологом_ и _эпилогом_.

```x86asm
aplusb:
  push rbp
  mov rbp, rsp

  lea eax, [rdi + rsi]

  pop rbp
  ret
```

В регистр `rbp` сохраняется _граница фрейма_ --- значение `rsp` на момент
входа в функцию. Также сохраняется на стек предыдущее значение `rbp`, которое
было записано другой функцией, вызвавшей `aplusb`. В конце `aplusb` это
предыдущее значение можно восстановить через `pop`.

Если все функции содержат такой пролог и эпилог, можно в произвольный момент
исполнения построить _стектрейс_ процесса --- стек функций, которые сейчас
исполняются.

<img data-src="stacktrace.svg">

1. Адреса инструкций (`rip` и адреса возврата, записанные на стеке) можно
   отобразить в номера строк в исходниках, используя дебаг-символы (или просто
   в названия функций, если дебаг-символов нет).
1. Поскольку предыдущий `rbp` сохраняется на стек сразу же при входе в функцию,
   он обязательно лежит рядом с адресом возврата. А текущий `rbp` содержит
   адрес предыдущего значения `rbp`, сохраненный на стеке.
1. Таким образом, по адресу `[rbp + 8]` лежит адрес возврата, а по адресу
   `[rbp]` --- предыдущий `rbp`. Можно прочитать адрес возврата, отобразить его
   в номер строки в исходниках, а потом прочитать предыдущий `rbp` и повторить
   то же самое для предыдущего фрейма.

Такой способ построения стектрейса может использовать gdb и некоторые
[профилировщики](https://www.brendangregg.com/blog/2024-03-17/the-return-of-the-frame-pointers.html).
