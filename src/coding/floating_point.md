# Числа с плавающей точкой

Универсальный тип, допускающий и достаточно большие, и достаточно точные
значения --- это `float` или `double`. Его представление задается стандартом
[IEEE 754](https://en.wikipedia.org/wiki/IEEE_754). Мы разберем подробно, как
устроен `float`, `double` отличается от него только длиной.

## Scientific notation

Основная идея --- использовать _scientific notation_. Это способ записи
дробных чисел в виде \\( \\pm MeE := \\pm M \cdot \\mathrm{base}^E  \\). Здесь
\\( \\mathrm{base} \\) --- основание системы счисления, \\( M \\) ---
мантисса (удобно считать, что она всегда неотрицательная), \\( E \\) ---
экспонента. Например, \\( 123.456e-7.8 = 123.456 \cdot 10^{-7.8} \\) в
десятичной системе.

Минус такой записи в том, что представление числа не единственно. Например
\\(1.2e3 = 0.12e4 = 120e-2 \\). Чтобы это исправить, можно рассматривать
нормализованную форму, в которой накладывается ограничение на мантиссу: \\( M
\in [1, \\mathrm{base}) \\). В таком виде единственным образом записываются все
числа, кроме нуля. Действительно, если число ненулевое, то поставим точку после
его старшей цифры и подгоним экспоненту --- это единственный вариант.
Например, \\( 0.0000123 = 1.23e-5 \\).

## Представление `float`

Внутреннее представление `float`-а состоит из похожих на scientific notation
компонент.

<img data-src="float.svg">

Здесь \\( s \\) --- бит знака (единица означает минус), \\( E \\) кодирует
экспоненту, а \\( M \\) --- мантиссу. Значение `float`-а вычисляется по
формуле \\( (-1)^s \times 2^{E - \\mathrm{bias}} \times \\overline{1.M} \\).
Число \\( E \\) кодируется как беззнаковый инт, но потом из него вычитается
смещение \\( \\mathrm{bias} = \\lfloor (2^{\\mathrm{len}(E)} - 1) / 2 \\rfloor
\\), где \\( \\mathrm{len}(E) \\) --- длина \\( E \\) в битах. Здесь \\(
(2^{\\mathrm{len}(E)} - 1) \\) --- максимальное значение \\( E \\), от
которого берем половину, чтобы получить \\( \\mathrm{bias} \\). Выражение \\(
\\overline{1.M} \\) --- дробное двоичное число, в котором после точки стоят
биты \\( M \\). В начале единица т.к. мы будем использовать нормализованную
scientific notation, а в двоичной системе она всегда начинается с "\\( 1. \\)"
Например, \\( 0.00110_2 = 1.10_2e-11_2 \\). Таким образом можно сэкономить один
бит, если явно нe включать "\\( 1. \\)" в мантиссу.

Для `float`-а \\( \\mathrm{bias} = 127 \\). На картинке \\( s = 1 \\), \\( E =
10010011_2 = 147 \\), \\( \\overline{1.M} = 1.11101010101011011101011_2 =
1.916715025901794 \\). Поэтому итоговое число \\( (-1) \\times 2^{147 - 127}
\\times 1.916715025901794 = -2.009821374999999545344 \\times 10^6 \\).

## Представление `double`

Оно отличается только длиной мантиссы и экспоненты.

<img data-src="double.svg">

## Специальные значения

Экспоненты \\( E = 0\dots0_2 \\) и \\( E = 1\dots1_2 \\) зарезервированы для
специальных значений.
1. Если \\( E = 0\dots0_2 \\) и \\( M = 0\dots0_2 \\), то `float` содержит
   \\(\pm 0 \\) в зависимости от бита знака \\( s \\). Эти нули считаются
   равными. Есть смысл их различать, потому что `float`-у может не хватить
   точности, чтобы представить очень маленькое по модулю значение. Тогда он
   округлится к нулю, но мы хотя бы сохраним информацию о знаке.
1. Если \\( E = 1\dots1_2 \\) и \\( M = 0\dots0_2 \\), то `float` считается
   равным \\( +\infty \\) или \\( -\infty \\)в зависимости от бита знака \\( s
   \\). Бесконечность можно получить при переполнении `float`-а либо если
   поделить что-то ненулевое на ноль. Такое поведение оправдано, потому что
   вычисления во `float`-ах в любом случае только приближенные, и иногда
   некорректное деление на ноль неотличимо от корректного деления на очень
   маленькое число. Поэтому решили обойтись без ошибок.
1. Если \\( E = 1\dots1_2 \\) и \\( M \neq 0\dots0_2 \\), то внутри `float`-а
   лежит специальное значение `NaN` (not a number). `NaN`-ы возникают в
   результате противоречивых арифметических операций. Например, если сложить \\(
   +\infty \\) и \\( -\infty \\) либо поделить ноль на ноль. По определению
   считается, что `NaN` ничему не равен (в том числе `NaN != NaN`). Любые
   арифметические операции с `NaN`-ом возвращают `NaN`.
1. Если \\( E = 0\dots0_2 \\), и \\( M \neq 0\dots0_2 \\), то `float`
   закодирован в
   [денормализованной](https://en.wikipedia.org/wiki/Subnormal_number) форме.
   Это означает, что в формуле теперь используется \\( 0.M \\) вместо \\( 1.M
   \\), а в качестве экспоненты подставляется минимальное "обычное" значение \\(
   E = 0\dots1_2 \\): \\( (-1)^s \times 2^{1 - \\mathrm{bias}} \times
   \\overline{0.M} \\).

## Денормализованные числа

Денормализованная форма нужна по двум причинам. Во-первых, в принципе для
представления очень маленьких по модулю чисел. Во-вторых (что более важно),
чтобы избежать _underflow_ при вычитании близких `float`-ов --- округления к
нулю из-за недостатка точности.

Рассмотрим такой пример: \\( 1.10_2 \\times 2^{-126} - 1.01_2 \\times 2^{-126} =
1 \\times 2^{-128} \\). Упс. Оба слагаемых были представимы `float`-ами, а
разность --- уже нет. Она должна округлиться к нулю, т.к. для `float`-а \\(
\\mathrm{bias} = 127 \\), поэтому минимальное значение экспоненты \\( 1 - 127 =
-126 \\). Это плохо, потому что вычитали неравные числа, и ноль получился
неожиданно. С денормализованными числами такой проблемы не будет: разность
запишется как \\( 0.1 \\times 2^{-126} \\). Более того, вообще никакие сложения
и вычитания не приведут к underflow, потому что минимальное расстояние между
соседними `float`-ами само представимо `float`-ом (это минимальный по модулю
`float` среди денормализованных).

Денормализованные числа встречаются с нормализованными на значениях \\( (-1)^s
\times 2^{1 - \\mathrm{bias}} \times 0.1\dots1_2 \\) и \\( (-1)^s \times 2^{1 -
\\mathrm{bias}} \times 1.0\dots0_2 \\). Они заполняют "underflow gap" ---
пространство между нулем и минимальным по модулю нормализованным числом.

## Точность

`float`-ы плохи тем, что их точность уменьшается с увеличением модуля числа.
Около нуля они встречаются очень частно, а потом промежутки между ними начинают
расти.

<img data-src="number_line.svg">

Это связано с тем, что для представления больших чисел нужна большая
экспонента. А если экспонента большая, то даже изменение младшего бита мантиссы
приводит к большому сдвигу, т.к. мантисса умножается на экспоненту.

Например, `float` может честно представлять целые числа длиной до 24 знаков в
двоичной записи. Потому что длина мантиссы --- 23 бита плюс один "неявный"
бит для "\\( 1. \\)" в начале. В мантиссу можно упаковать биты целого числа, а
потом подобрать экспоненту. Например, \\( 10 = 1010_2 = 2^3 \\times 1.010 \\).
Если число длиннее 24 двоичных знаков, то придется брать экспоненту как минимум
\\( 2^{24} \\). При умножении на мантиссу, у которой 23 знака после запятой,
получим число с нулем на конце, т.е. четное. Получается, большие нечетные числа
уже не представимы --- увеличились промежутки между соседними `float`-ами.

Таким образом, `float` может точно представлять 24-битные инты со знаком, а
`double` --- 53-битные (т.к. его длина мантиссы \\( 52 + 1 = 53 \\) бита).
Это уже достаточно большой диапазон значений. Если за него выйти, то сначала
будут округления к ближайшему четному числу, потом к ближайшему кратному 4 и
т.д.
