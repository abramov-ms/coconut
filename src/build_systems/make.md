# Make

Исторически люди использовали general purpose сборочные системы, чтобы билдить
Си. Например, [`make`](https://man7.org/linux/man-pages/man1/make.1p.html). Мейк
не привязан ни к какому конкретному языку, про Си он ничего не знает. Все что
умеет мейк &mdash; следить за зависимостями между файлами и выполнять указанные
команды, чтобы сгенерировать из исходников артефакты (для Си артефакты
&mdash; это объектники, итоговые exe-шники и либы).

В сборочном скрипте на мейке описываются таргеты &mdash; промежуточные шаги
сборки. Таргеты могут зависеть от файлов либо друг от друга (например, нам
нечего линковать, пока мы не скомпилировали объектники).  Формат описания
таргета такой
```makefile
target_name: dependency1 dependency2 ...
   command1
   command2
   ...
```

Например, вот шуточный `Hello, World!` на мейке.
```makefile
# Makefile

all: hello world

hello:
   echo 'Hello'

world:
   echo 'World'
```
Традиционно сборочный скрипт называется `Makefile`, а таргет по умолчанию
&mdash; `all`, но это можно переопределить. Теперь если выполнить `make -s`,
получим вывод
```
Hello
World
```
Если убрать `-s`, мейк еще будет печатать сами команды сборки. Чтобы "собрать"
только `hello`, можно выполнить `make -s hello`.

Реальный мейкфайл мог бы выглядеть так.
```makefile
all: main aplusb
	clang main.o aplusb.so -rpath . -o main

main: main.c aplusb.h
	clang main.c -c -o main.o

aplusb: aplusb.c aplusb.h
	clang aplusb.c -shared -o aplusb.so
```
Здесь `main` и `aplusb` будут пересобираться каждый раз, когда меняются
исходники. Таргет `all` будет пересобираться, если пересобираются `main` либо
`aplusb`. Таким образом мейк следит за зависимостями и позволяет делать
инкрементальные билды, то есть компилировать заново только те части, которые
изменились.

# Другие билд-системы

Кроме мейка есть еще десяток мейк-подобных сборочных систем, которые тоже
работают с таргетами и зависимостями. Самая важная &mdash;
[Ninja](https://ninja-build.org/). Ниндзя кроссплатформенный. Он работает чуть
быстрее мейка и чуть лучше трекает зависимости между таргетами, поэтому его
инкрементальные билды эффективнее. Обычно вместо мейка лучше использовать именно
его. Новый синтаксис сборочных скриптов учить не придется, т.к. за нас их будет
писать CMake, но об этом позже.

На виндовс сейчас используется
[MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild?view=vs-2022),
он придуман специально для C/C++ и .NET. В MSBuild сборка описывается очень
страшными XML-файлами, но обычно их не создают вручную, а генерируют через Visual
Studio либо CMake.
