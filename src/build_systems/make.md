# Make

Исторически люди использовали general purpose сборочные системы, чтобы билдить
Си. Например, [`make`](https://man7.org/linux/man-pages/man1/make.1p.html). Мейк
не привязан ни к какому конкретному языку, про Си он ничего не знает. Все что
умеет мейк --- следить за зависимостями между файлами и выполнять указанные
команды, чтобы сгенерировать из исходников артефакты (для Си артефакты
--- это объектники, исполняемые файлы и либы).

В сборочном скрипте на мейке описываются таргеты --- промежуточные шаги сборки.
Таргеты могут зависеть от файлов либо друг от друга (например, нам нечего
линковать, пока мы не скомпилировали объектники).  Формат описания таргета
такой

```makefile
target_name: dependency1 dependency2 ...
   command1
   command2
   ...
```

Например, вот шуточный `Hello, World!` на мейке.

```makefile
# Makefile

all: hello world

hello:
   echo 'Hello'

world:
   echo 'World'
```

Традиционно сборочный скрипт называется `Makefile`, а таргет по умолчанию ---
`all`, но это можно переопределить. Теперь если выполнить `make -s`, получим
вывод

```
Hello
World
```

Если убрать `-s`, мейк еще будет печатать сами команды сборки. Чтобы "собрать"
только `hello`, можно выполнить `make -s hello`.

Реальный мейкфайл мог бы выглядеть так.

```makefile
all: main aplusb
	clang main.o aplusb.so -rpath . -o main

main: main.c aplusb.h
	clang main.c -c -o main.o

aplusb: aplusb.c aplusb.h
	clang aplusb.c -shared -o aplusb.so
```

Здесь `main` и `aplusb` будут пересобираться каждый раз, когда меняются
исходники. Таргет `all` будет пересобираться, если пересобираются `main` либо
`aplusb`. Таким образом мейк следит за зависимостями и позволяет делать
_инкрементальные_ билды, то есть компилировать заново только те части, которые
изменились.

# Другие билд-системы

Кроме мейка существует еще десяток мейк-подобных сборочных систем, которые тоже
работают с таргетами и зависимостями.

Вероятно когда-нибудь вам встретится [Ninja](https://ninja-build.org/). Ниндзя
кроссплатформенный. Он работает чуть быстрее мейка и чуть лучше понимает
зависимости между таргетами, поэтому его инкрементальные билды эффективнее.
Вместо мейка можно использовать его. Новый синтаксис сборочных скриптов учить
не придется, т.к. за нас их будет писать CMake, но об этом позже.

На виндовс обычно используется
[MSBuild](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild?view=vs-2022),
он разработан специально для C/C++ и .NET. В MSBuild сборка описывается очень
страшными XML-файлами, хотя, как правило, их не пишут вручную, а генерируют
через Visual Studio либо CMake.
