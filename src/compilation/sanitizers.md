# Санитайзеры

Чтобы проверять корректность программ, существуют _санитайзеры_. Это специальные
инструменты, которые в рантайме следят, что делает приложение, и сообщают,
когда произошло что-то плохое.

Санитайзеры работают за счет
1. Compile-time преобразований кода программы (эти преобразования называются
   инструментированием).
2. Специальных библиотек, в которых прописана логика проверок на корректность.

Про алгоритмы работы санитайзеров можно прочитать
[здесь](https://github.com/google/sanitizers/wiki/).

Есть более-менее стандартный набор санитайзеров, которые поддерживаются в gcc и
clang, я оставлю ссылки на clang. Наиболее полезные ---
[AddressSanitizer](https://clang.llvm.org/docs/AddressSanitizer.html) (ASan),
[UndefinedBehaviorSanitizer](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)
(UBSan) и [ThreadSanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html)
(TSan). ASan проверяет, что нет утечек и обращений к освобожденной памяти.
UBSan, --- что нет UB (например, переполнения знаковых интов, невыровненных
обращений к памяти и т.д.). TSan проверяет корректность многопоточных программ,
это совсем другая история.

Посмотрим, как работает ASan. Сначала напишем простую утечку.

```c
#include <stdlib.h>

int main() {
  malloc(1024);
  return 0;
}
```

Чтобы подключить ASan, нужно передать компилятору флаг `-fsanitize=address`.

```
gcc main.c -fsanitize=address -o main
```

При компиляции кланг заменит стандартные `malloc()` и `free()` на специальные
реализации из библиотеки ASan, которые следят, чтобы вся аллоцированная память
была освобождена.

Теперь если запустить `main`, получим сообщение от LeakSanitizer-а, который
входит в комплект AddressSanitizer-а.

```
=================================================================
==46288==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 1024 byte(s) in 1 object(s) allocated from:
    #0 0x55fb8ec43c59 in __interceptor_malloc (/home/dgdh/main+0xd6c59) (BuildId: f88b8c36603f7685cc8f7ad771b219c3dd50e4d0)
    #1 0x55fb8ec8a038 in main (/home/dgdh/main+0x11d038) (BuildId: f88b8c36603f7685cc8f7ad771b219c3dd50e4d0)
    #2 0x7fcf3ce27ccf  (/usr/lib/libc.so.6+0x27ccf) (BuildId: 316d0d3666387f0e8fb98773f51aa1801027c5ab)

SUMMARY: AddressSanitizer: 1024 byte(s) leaked in 1 allocation(s).
```

Некоторые санитайзеры можно комбинировать. Чтобы включить одновременно ASan и
UBSan, нужно передать клангу флаг `-fsanitize=address,undefined`.

Код с санитайзерами работает медленее. Например, ASan своими проверками
замедляет программу примерно в 2 раза, а TSan --- в 5--10 раз. Тем не менее, это
очень полезные инструменты, без которых тяжело жить.

> Еще есть [MemorySanitizer](https://clang.llvm.org/docs/MemorySanitizer.html),
> он проверяет, что программа читает только инициализированную память. ASan
> тоже делает что-то похожее, но у него ограниченный пул проверок (
> `heap-use-after-free`, `heap-buffer-overflow`, `stack-buffer-overflow` и
> некоторые другие). MSan же проверяет вообще все доступы к памяти, даже чтения
> отдельных бит в [битовых
> полях](https://en.cppreference.com/w/cpp/language/bit_field). Downside в том,
> что это будет корректно работать, только если весь код целиком скомпилирован
> с MSan-ом (включая все зависимости, даже стандартную библиотеку). Поэтому
> MSan на практике редко используют.

> Кроме санитайзеров, бывают еще другие тулы, например
> [valgrind](https://valgrind.org/). Валгринд умеет примерно то же самое, что
> ASan и MSan, но еще содержит дополнительные инструменты (например cachegrind
> для симуляции работы кэшей). Отличие валгринда от санитайзеров в том, что он
> в рантайме инструментирует код на уровне ассемблерных инструкций и симулирует
> их исполнение на виртуальном CPU. Плюсы такого подхода в том, что
> 1. За счет виртуального CPU есть полный контроль над исполнением кода, и
>    доступно продвинутое профилирование.
> 1. Нет необходимости в сложных билдах, как в случае с MSan-ом. Для
>    использования валгринда достаточно иметь дебаг-символы вашего
>    приложения.
>
> Зато замедление будет гораздо сильнее, чем от санитайзеров. Подробное
> сравнение с ASan и MSan можно посмотреть
> [здесь](https://github.com/google/sanitizers/wiki/AddressSanitizerComparisonOfMemoryTools).
