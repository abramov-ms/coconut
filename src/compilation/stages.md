# Этапы компиляции

Посмотрим этапы компиляции на примере `Hello, World!`.

```c
// main.c

{{#include main.c}}
```

Она происходит в несколько шагов, которые можно пронаблюдать с помощью
специальных флагов компилятора.

1. Сначала разворачиваются директивы препроцессора (`#include`, `#define`,
   `#ifdef` и [другие](https://en.cppreference.com/w/c/preprocessor)). В нашем
   случае в текст программы будет скопирован хедер `stdio.h`, получится много
   кода. Можно посмотреть на результат препроцессинга с помощью команды

   ```bash
   gcc -E main.c -o main_pp.c
   ```

   Флаг `-E` говорит компилятору, что нужно сделать только препроцессинг и
   остановиться. У меня получилось [вот это](main_pp.c).

   > Строки вида `# linenum filename flags` --- это
   > [linemarker-ы](https://gcc.gnu.org/onlinedocs/gcc-8.5.0/cpp/Preprocessor-Output.html#Preprocessor-Output),
   > похожие по смыслу на директиву
   > [`#line`](https://en.cppreference.com/w/c/preprocessor/line). С их помощью
   > можно восстановить, из каких файлов были взяты куски текста.

2. Происходит преобразование Си в инструкции _ассемблера_ целевой платформы. Пока
   достаточно знать, что ассемблер --- низкоуровневое описание действий для
   процессора. Посмотреть на ассемблер можно c помощью
   флага `-S`:

   ```bash
   gcc -S main_pp.c -o main.S
   ```

   В этот раз получается файл поменьше, т.к. все неиспользуемые определения
   были вырезаны.

   ```x86asm
   // main.S

       .file	"main.c"
       .text
       .section	.rodata
   .LC0:
       .string	"Hello, World!"
       .text
       .globl	main
       .type	main, @function
   main:
   .LFB0:
       .cfi_startproc
       pushq	%rbp
       .cfi_def_cfa_offset 16
       .cfi_offset 6, -16
       movq	%rsp, %rbp
       .cfi_def_cfa_register 6
       leaq	.LC0(%rip), %rax
       movq	%rax, %rdi
       call	puts@PLT
       movl	$0, %eax
       popq	%rbp
       .cfi_def_cfa 7, 8
       ret
       .cfi_endproc
   .LFE0:
       .size	main, .-main
       .ident	"GCC: (GNU) 14.2.1 20240805"
       .section	.note.GNU-stack,"",@progbits
   ```

3. Выполняется компиляция ассемблера в т.н. _объектный файл_ --- для этого есть
   флаг `-c`. После выполнения

   ```bash
   gcc -c main.S -o main.o
   ```

   появится объектник `main.o`, он содержит машинные инструкции и некоторые
   метаданные. Файл бинарный, поэтому просто прочитать его не получится.
   Но преобразование ассемблера в машинные инструкции в целом обратимо: можно
   _дизассемблировать_ `main.o` с помощью утилиты
   [`objdump`](https://man7.org/linux/man-pages/man1/objdump.1.html). Команда

   ```bash
   objdump --disasseble=main main.o
   ```

   выведет что-то такое

   ```x86asm
   main.o:     file format elf64-x86-64
   
   
   Disassembly of section .init:
   
   Disassembly of section .plt:
   
   Disassembly of section .text:
   
   0000000000001139 <main>:
       1139:       55                      push   %rbp
       113a:       48 89 e5                mov    %rsp,%rbp
       113d:       48 8d 05 c0 0e 00 00    lea    0xec0(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
       1144:       48 89 c7                mov    %rax,%rdi
       1147:       e8 e4 fe ff ff          call   1030 <puts@plt>
       114c:       b8 00 00 00 00          mov    $0x0,%eax
       1151:       5d                      pop    %rbp
       1152:       c3                      ret
   
   Disassembly of section .fini:
   ```

   Слева записаны машинные коды, а справа --- их мнемоники, т.е.
   "человекочитаемые" ассемблерные инструкции с предыдущего шага. Кода стало
   меньше, потому что мы дизассемблировали только инструкции `main()`. В
   объектнике, например, еще хранится отдельно секция данных со строкой
   `"Hello, World!"`, ее объявление можно найти в нашем `main.S`.

4. Последний этап --- линковка. Команда

   ```
   gcc main.o -o main
   ```

   превращает объектный файл в исполняемый. Зачем нужна линковка? Во-первых мог
   быть не один файл `main.c`, а несколько _единиц трансляции_ --- исходников
   `.c`, которые преобразуются в объектные файлы `.o`. Их нужно совместить в
   один executable, чем и занимается линковщик. Во-вторых программа могла
   использовать внешние библиотеки, как минимум libc. Их тоже нужно включить в
   итоговый бинарник. Линковкой обычно занимается не сам компилятор, а
   отдельная программа. В нашем случае под капотом gcc запустит
   [`ld`](https://man7.org/linux/man-pages/man1/ld.1.html), чтобы получить
   исполняемый файл.

## Платформозависимость

Код неизбежно становится платформозависимым уже на втором шаге, когда получили
ассемблер. Ассемблерные инструкции будут разными в зависимости от архитектуры
процессора и операционной системы, под которые компилируемся. Например, если
компилировать под процессоры ARM (конкретно
[AArch64](https://en.wikipedia.org/wiki/AArch64)), получится вот такой
ассемблер.

```armasm
        .arch armv8-a
        .file   "main.c"
        .text
        .section        .rodata
        .align  3
.LC0:
        .string "Hello, World!"
        .text
        .align  2
        .global main
        .type   main, %function
main:
        stp     x29, x30, [sp, -16]!
        add     x29, sp, 0
        adrp    x0, .LC0
        add     x0, x0, :lo12:.LC0
        bl      printf
        mov     w0, 0
        ldp     x29, x30, [sp], 16
        ret
        .size   main, .-main
        .ident  "GCC: (Linaro GCC 7.5-2019.12) 7.5.0"
```

Хорошая новость в том, что машинные коды практически один в один соответствуют
инструкциям ассемблера, поэтому можно считать ассемблер наиболее низкоуровневым
описанием программы. Если уметь его читать, можно рассуждать об исполнении кода
на уровне инструкций процессора.

> Такой процесс компиляции --- чудовищное легаси, которое нам досталось от Си и
> перешло в C++. У современных языков этапы компиляции другие, потому что нет
> разделения кода на хедеры и исходники, а есть просто модули. Даже если
> компилировать C++20 с
> [модулями](https://en.cppreference.com/w/cpp/language/modules), уже будет
> чуть-чуть иначе. Но несмотря на это формат итогового бинарника
> [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) и
> представление в ассемблере всегда одни и те же.

> Еще могут быть другие этапы сборки, если включить [link-time
> оптимизации](https://llvm.org/docs/LinkTimeOptimization.html). Вместе с LTO,
> оптимайзер одновременно видит несколько единиц трансляции и, например, может
> заинлайнить функцию из одного объектника в другой --- без LTO так не
> получится. В таком случае формат объектников отличается: в них будет
> содержаться не машинный код, а специальное промежуточное представление, с
> которым работает оптимайзер, --- например, [биткод
> LLVM](https://llvm.org/docs/BitCodeFormat.html).

