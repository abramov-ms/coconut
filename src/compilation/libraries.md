# Статические и динамические библиотеки

Разберемся, как линкуются библиотеки. Концептуально все библиотеки делятся на
статические и динамические. Статические во время линковки просто копируются в
итоговый бинарник, а в случае с динамическими в бинарник вставляется только путь
до файла библиотеки. Перед запуском программы операционная система ищет
динамические библиотеки по этим путям и подгружает их в память. Плюс
динамических либ в том, что несколько разных программ могут использовать одну и ту
же библиотеку, и ее не нужно каждый раз копировать. Например, libc используют
почти все программы, и было бы расточительно иметь копию внутри каждого
исполняемого файла. Поэтому динамические библиотеки еще называются разделяемыми.

Попробуем собрать оба вида библиотек и заиспользовать их.

```c
// aplusb.h

int sum(int a, int b);
```

```c
// aplusb.c

int sum(int a, int b) {
  return a + b;
}
```

```c
// main.c

#include <stdio.h>

#include "aplusb.h"

int main() {
  printf("%d\n", sum(1, 2));
  return 0;
}
```

1. Статические библиотеки --- просто архивы из объектных файлов. Создать
   архив можно с помощью тулов
   [`ar`](https://man7.org/linux/man-pages/man1/ar.1.html) либо
   [`llvm-ar`](https://llvm.org/docs/CommandGuide/llvm-ar.html). Стандартное
   расширение для статических библиотек --- `.a` (означает "archive").
   ```bash
   clang aplusb.c -c -o aplusb.o
   llvm-ar -qc libaplusb.a aplusb.o
   ```
   После этого использовать библиотеку можно так.
   ```bash
   clang main.c -c -o main.o
   clang libaplusb.a main.o -o main
   ```
   Процесс компиляции будет такой же, как если бы мы просто передали клангу
   объектники `main.o` и `aplusb.o`.

   Разархивировать статическую библиотеку тоже можно. Команда `llvm-ar -x
   libaplusb.a` извлекает обратно `aplusb.o`.
2. Динамические библиотеки больше похожи на исполняемые файлы, потому что они
   точно так же компилируются и линкуются. Из них уже не получится извлечь
   отдельные объектники. Стандартное расширение для динамических библиотек
   --- `.so` (от названия "shared object"). Для сборки надо передать
   компилятору флаг `-shared`.
   ```bash
   clang aplusb.c -shared -o aplusb.so
   ```
   Прилинковать библиотеку можно так.
   ```bash
   clang main.c -c -o main.o
   clang main.o aplusb.so -rpath . -o main
   ```
   Флаг `-rpath` указывает директории, в которых нужно искать динамические
   библиотеки при старте программы. В `rpath` по умолчанию есть дефолтные пути
   типа `/usr/lib`, у нас будет еще один кастомный путь --- текущая
   директория. `rpath` нужен, потому что при линковке динамическая библиотека
   может лежать в одном месте, а при запуске программы --- в другом
   (например, вы собираете `abplusb.so` в папке проекта, а при установке
   копируете в `/usr/lib`).

> Вообще линковаться к библиотекам правильнее не как написано выше, а через
> [флаги](https://clang.llvm.org/docs/ClangCommandLineReference.html#linker-options)
> `-l` и `-L`. С ними можно не привязываться к конкретному `.so` или `.a` файлу,
> а искать установленную либу просто по названию. Но это в любом случае лучше
> делать через симейк, а не руками.

# ldd

Есть утилита [`ldd`](https://man7.org/linux/man-pages/man1/ldd.1.html), которая
позволяет смотреть, от каких динамических библиотек зависит файл (название
--- сокращение от "ld dump"). Если прилинковать `aplusb.so` и выполнить `ldd
main`, увидим такой вывод.
```
linux-vdso.so.1 (0x00007ffe0574d000)
libaplusb.so => ./libaplusb.so (0x00007f17b0f31000)
libc.so.6 => /usr/lib/libc.so.6 (0x00007f17b0c00000)
/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007f17b0f3d000)
```
Здесь есть две особенные зависимости.
1. [`linux-vdso.so.1`](https://man7.org/linux/man-pages/man7/vdso.7.html)
   --- это такая штука, которая ускоряет сисколлы --- обращения к API
   линукса. Про vDSO мы поговорим позже.
2. [`/lib64/ld-linux-x86-64.so.2`](https://man7.org/linux/man-pages/man8/ld.so.8.html)
   --- рантаймовый линковщик, который перед стартом программы подгружает все
   остальные динамические библиотеки (это не то же самое, что линковщик `ld`,
   который вызывается во время сборки). Сам `ld-linux.so` shared object-ом не
   является. `ldd`  его показывает, потому что без рантаймового линковщика
   невозможен запуск exe-шников, зависящих от динамических библиотек, а суффикс
   `.so` нужен, чтобы отличать его от обычного compile-time `ld`.

